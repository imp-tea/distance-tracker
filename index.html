<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Green Square Distance Tracker</title>
    <style>
        /* Basic CSS to center and size video and canvas elements */
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            font-family: Arial, sans-serif;
        }
        video, canvas {
            width: 640px;
            height: 480px;
            border: 1px solid #333;
        }
    </style>
    <!-- Load OpenCV.js from CDN with defer attribute -->
    <script defer src="https://docs.opencv.org/3.4.0/opencv.js"></script>
</head>
<body>

<h2>Neon Green Square Distance Tracker</h2>
<!-- Video element to capture from webcam -->
<video id="videoElement" autoplay playsinline></video>

<!-- Canvas element to show the processed video with distance overlay -->
<canvas id="canvasOutput"></canvas>

<!-- Main JavaScript for the tracker functionality -->
<script>
async function checkAndRequestCameraPermission() {
    try {
        let permissionStatus = await navigator.permissions.query({ name: 'camera' });
        
        if (permissionStatus.state === 'denied') {
            alert("Camera access has been denied. Please enable it in your browser settings.");
            return;
        }

        // Try to access the webcam if permission isn't denied
        navigator.mediaDevices.getUserMedia({ video: true })
            .then(stream => {
                const video = document.getElementById('videoElement');
                video.srcObject = stream;
            })
            .catch(error => {
                console.error("Error accessing the webcam: ", error);
            });
    } catch (error) {
        console.error("Error checking camera permissions: ", error);
    }
}
document.addEventListener('DOMContentLoaded', function() {
    checkAndRequestCameraPermission();
    // Wait until OpenCV.js is fully loaded
    cv['onRuntimeInitialized'] = () => {
        const video = document.getElementById('videoElement');
        const canvas = document.getElementById('canvasOutput');
        const ctx = canvas.getContext('2d');

        // Access webcam
        navigator.mediaDevices.getUserMedia({ video: true }).then(stream => {
            video.srcObject = stream;
        });

        video.addEventListener('play', () => {
            const cap = new cv.VideoCapture(video);
            const frame = new cv.Mat(video.height, video.width, cv.CV_8UC4);
            const hsv = new cv.Mat();
            const mask = new cv.Mat();

            function processFrame() {
                try {
                    cap.read(frame);
                    cv.cvtColor(frame, hsv, cv.COLOR_RGBA2RGB);
                    cv.cvtColor(hsv, hsv, cv.COLOR_RGB2HSV);

                    // Define HSV range for neon green; adjust as needed
                    let lower = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [40, 150, 150, 0]);
                    let upper = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [80, 255, 255, 255]);
                    cv.inRange(hsv, lower, upper, mask);

                    // Find contours
                    let contours = new cv.MatVector();
                    let hierarchy = new cv.Mat();
                    cv.findContours(mask, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

                    console.log("Contours found:", contours.size());
                    for (let i = 0; i < contours.size(); i++) {
                        let cnt = contours.get(i);
                        let rect = cv.boundingRect(cnt);

                        // Estimate distance based on bounding box width
                        const knownDistance = 24; // Calibrated distance in inches
                        const realWidth = 6; // Real width of object in inches
                        const observedWidth = rect.width;
                        const distance = (knownDistance * realWidth) / observedWidth;

                        // Draw bounding box and distance text on the frame
                        cv.rectangle(frame, new cv.Point(rect.x, rect.y), new cv.Point(rect.x + rect.width, rect.y + rect.height), [0, 255, 0, 255], 2);
                        cv.putText(frame, `${distance.toFixed(2)} inches`, new cv.Point(rect.x, rect.y - 10), cv.FONT_HERSHEY_SIMPLEX, 0.6, [0, 255, 0, 255]);
                    }

                    // Render frame on the canvas
                    cv.imshow('canvasOutput', frame);

                    // Clean up
                    contours.delete();
                    hierarchy.delete();
                    lower.delete();
                    upper.delete();

                    // Process the next frame
                    requestAnimationFrame(processFrame);
                } catch (err) {
                    console.error("Error in processing frame:", err);
                }
            }

            processFrame();
        });
    };
});
</script>

</body>
</html>
