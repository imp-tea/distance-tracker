<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Huddleston's Distance Grapher</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
        }
        .container {
            display: flex;
            height: 100vh;
        }
        .left-side, .right-side {
            flex: 1;
            padding: 20px;
            box-sizing: border-box;
        }
        .left-side {
            border-right: 1px solid #ccc;
        }
        .controls, .calibration-controls {
            margin-top: 10px;
            margin-bottom: 10px;
        }
        .controls label, .calibration-controls label {
            margin-right: 5px;
        }
        video, canvas#canvasOutput {
            width: 480px;
            height: 360px;
            border: 2px solid #333;
        }
        /* Hide the video element */
        #videoElement {
            display: none;
        }
        /* Style for right-side elements */
        .graph-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #distanceChart {
            width: 100%;
            max-height: 300px;
        }
        .graph-buttons {
            margin-top: 10px;
        }
        .graph-buttons button {
            margin-right: 5px;
        }
        .controls label {
            display: inline-block;
            margin-right: 5px;
        }
        .controls input[type="color"],
        .controls input[type="range"] {
            vertical-align: middle;
            margin-right: 10px;
        }
    </style>
    <!-- Load OpenCV.js from CDN with defer attribute -->
    <script defer src="https://docs.opencv.org/3.4.0/opencv.js"></script>
    <!-- Load Chart.js from CDN -->
    <script defer src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>

<h2 style="text-align:center;">Huddleston's Distance Grapher</h2>

<div class="container">
    <div class="left-side">
        <!-- Canvas element to show the processed video with distance overlay -->
        <canvas id="canvasOutput"></canvas>

        <div class="calibration-controls">
            <label for="distanceInput">Distance from Camera (inches):</label>
            <input type="number" id="distanceInput" name="distanceInput" value="24">
            <br>
            <label for="widthInput">Width of Object (inches):</label>
            <input type="number" id="widthInput" name="widthInput" value="6">
            <br>
            <button id="calibrateButton">Calibrate!</button>
        </div>

        <!-- Video element to capture from webcam (hidden) -->
        <video id="videoElement" autoplay playsinline></video>
    </div>

    <div class="right-side">
        <div class="graph-container">
            <canvas id="distanceChart"></canvas>
            <div class="graph-buttons">
                <button id="beginGraphingButton">Begin Graphing</button>
                <button id="clearGraphButton">Clear Graph</button>
            </div>
        </div>
         <!-- Controls below the graph -->
        <div class="controls">
            <label for="colorPicker1">Select Color 1:</label>
            <input type="color" id="colorPicker1" name="colorPicker1" value="#7ABF36">
            <label for="sensitivityRange1">Sensitivity:</label>
            <input type="range" id="sensitivityRange1" name="sensitivityRange1" min="0" max="100" value="50">
            <br>
            <label for="colorPicker2">Select Color 2:</label>
            <input type="color" id="colorPicker2" name="colorPicker2" value="#FF69B4"> <!-- Neon pink -->
            <label for="sensitivityRange2">Sensitivity:</label>
            <input type="range" id="sensitivityRange2" name="sensitivityRange2" min="0" max="100" value="50">
        </div>
    </div>
</div>

<!-- Main JavaScript for the tracker functionality -->
<script>
    // Global variables to track readiness
    let videoReady = false;
    let openCVReady = false;

    // HSV ranges for both colors
    let lowerHSV1 = [40, 150, 150, 0]; // Initial lower HSV range for color 1
    let upperHSV1 = [80, 255, 255, 255]; // Initial upper HSV range for color 1

    let lowerHSV2 = [160, 150, 150, 0]; // Initial lower HSV range for color 2
    let upperHSV2 = [179, 255, 255, 255]; // Initial upper HSV range for color 2

    // Calibration variables
    let knownDistance = 24; // default value in inches
    let realWidth = 6; // default value in inches
    let focalLength = null; // will be calculated during calibration

    // Graphing variables
    let chart; // Chart.js chart instance
    let graphing = false; // Flag to indicate if graphing is active
    let startTime = null; // Variable to track the start time of graphing
    
    // Helper function to get the center of a rectangle
    function getCenter(rect) {
        return {
            x: rect.x + rect.width / 2,
            y: rect.y + rect.height / 2
        };
    }
    // Poll every 100ms to check if OpenCV is loaded
    function checkOpenCVReady() {
        if (cv && cv.Mat) {
            console.log("OpenCV.js is ready.");
            openCVReady = true;
            if (videoReady) {
                startProcessing();
            }
        } else {
            setTimeout(checkOpenCVReady, 100); // Retry every 100ms
        }
    }

    // DOMContentLoaded event
    document.addEventListener('DOMContentLoaded', function() {
        console.log("DOM Content loaded...");
        const video = document.getElementById('videoElement');
        const colorPicker1 = document.getElementById('colorPicker1');
        const sensitivityRange1 = document.getElementById('sensitivityRange1');
        const colorPicker2 = document.getElementById('colorPicker2');
        const sensitivityRange2 = document.getElementById('sensitivityRange2');
        const calibrateButton = document.getElementById('calibrateButton');
        const beginGraphingButton = document.getElementById('beginGraphingButton');
        const clearGraphButton = document.getElementById('clearGraphButton');

        // Access webcam
        navigator.mediaDevices.getUserMedia({ video: true })
        .then(stream => {
            video.srcObject = stream;
            console.log("Video feed successfully accessed");
        })
        .catch(error => {
            console.error("Error accessing the webcam: ", error);
        });

        // Wait for video to be ready
        video.addEventListener('canplay', () => {
            console.log("Video is ready to play");
            videoReady = true;
            if (openCVReady) {
                startProcessing();
            }
        });

        // Check OpenCV initialization
        checkOpenCVReady();

        // Add event listeners to color pickers and sensitivity sliders
        colorPicker1.addEventListener('input', updateColorRange);
        sensitivityRange1.addEventListener('input', updateColorRange);
        colorPicker2.addEventListener('input', updateColorRange);
        sensitivityRange2.addEventListener('input', updateColorRange);

        // Add event listener to calibrate button
        calibrateButton.addEventListener('click', calibrateCamera);

        // Add event listeners for graphing buttons
        beginGraphingButton.addEventListener('click', beginGraphing);
        clearGraphButton.addEventListener('click', clearGraph);

        // Initialize color range and chart
        updateColorRange();
        initializeChart();
    });

    function updateColorRange() {
        // Color 1
        const colorPicker1 = document.getElementById('colorPicker1');
        const sensitivityRange1 = document.getElementById('sensitivityRange1');
        let sensitivity1 = parseInt(sensitivityRange1.value); // 0 to 100

        let hexColor1 = colorPicker1.value;
        let hsvColor1 = hexToHSV(hexColor1);
        let h1 = hsvColor1[0];
        let s1 = hsvColor1[1];
        let v1 = hsvColor1[2];

        let rangeSensitivity1 = 100 - sensitivity1;

        let hueRange1 = (rangeSensitivity1 / 100) * 179;
        let satRange1 = (rangeSensitivity1 / 100) * 255;
        let valRange1 = (rangeSensitivity1 / 100) * 255;

        let lowerH1 = Math.max(h1 - hueRange1 / 2, 0);
        let upperH1 = Math.min(h1 + hueRange1 / 2, 179);

        let lowerS1 = Math.max(s1 - satRange1 / 2, 0);
        let upperS1 = Math.min(s1 + satRange1 / 2, 255);

        let lowerV1 = Math.max(v1 - valRange1 / 2, 0);
        let upperV1 = Math.min(v1 + valRange1 / 2, 255);

        lowerHSV1 = [lowerH1, lowerS1, lowerV1, 0];
        upperHSV1 = [upperH1, upperS1, upperV1, 255];

        // Color 2
        const colorPicker2 = document.getElementById('colorPicker2');
        const sensitivityRange2 = document.getElementById('sensitivityRange2');
        let sensitivity2 = parseInt(sensitivityRange2.value); // 0 to 100

        let hexColor2 = colorPicker2.value;
        let hsvColor2 = hexToHSV(hexColor2);
        let h2 = hsvColor2[0];
        let s2 = hsvColor2[1];
        let v2 = hsvColor2[2];

        let rangeSensitivity2 = 100 - sensitivity2;

        let hueRange2 = (rangeSensitivity2 / 100) * 179;
        let satRange2 = (rangeSensitivity2 / 100) * 255;
        let valRange2 = (rangeSensitivity2 / 100) * 255;

        let lowerH2 = Math.max(h2 - hueRange2 / 2, 0);
        let upperH2 = Math.min(h2 + hueRange2 / 2, 179);

        let lowerS2 = Math.max(s2 - satRange2 / 2, 0);
        let upperS2 = Math.min(s2 + satRange2 / 2, 255);

        let lowerV2 = Math.max(v2 - valRange2 / 2, 0);
        let upperV2 = Math.min(v2 + valRange2 / 2, 255);

        lowerHSV2 = [lowerH2, lowerS2, lowerV2, 0];
        upperHSV2 = [upperH2, upperS2, upperV2, 255];
    }

    function hexToHSV(hex) {
        // Convert hex to RGB first
        let r = parseInt(hex.substr(1,2),16);
        let g = parseInt(hex.substr(3,2),16);
        let b = parseInt(hex.substr(5,2),16);

        // Convert RGB to HSV
        let hsv = rgbToHSV(r, g, b);
        return hsv;
    }

    function rgbToHSV(r, g, b) {
        r /= 255;
        g /= 255;
        b /= 255;

        let max = Math.max(r, g, b), min = Math.min(r, g, b);
        let h, s, v = max;

        let d = max - min;
        s = max == 0 ? 0 : d / max;

        if(max == min){
            h = 0; // achromatic
        } else {
            switch(max){
                case r: h = ((g - b) / d + (g < b ? 6 : 0)); break;
                case g: h = ((b - r) / d + 2); break;
                case b: h = ((r - g) / d + 4); break;
            }
            h /= 6;
        }

        return [h * 179, s * 255, v * 255]; // OpenCV uses H ranges from 0 to 179, S and V from 0 to 255
    }

    function startProcessing() {
        const video = document.getElementById('videoElement');
        const canvasOutput = document.getElementById('canvasOutput');
        const canvasFrame = document.createElement('canvas');
        // Using willReadFrequently attribute for better performance
        const ctx = canvasFrame.getContext('2d', { willReadFrequently: true });

        // Set canvas sizes to match video dimensions
        const videoWidth = video.videoWidth;
        const videoHeight = video.videoHeight;
        console.log("Video dimensions:", videoWidth, videoHeight);

        canvasOutput.width = videoWidth;
        canvasOutput.height = videoHeight;
        canvasFrame.width = videoWidth;
        canvasFrame.height = videoHeight;

        const src = new cv.Mat(videoHeight, videoWidth, cv.CV_8UC4);
        const hsv = new cv.Mat();

        function processFrame() {
            try {
                // Clear the previous frame and apply the horizontal flip
                ctx.save();  // Save the current context state
                ctx.translate(videoWidth, 0); // Move the context to the right edge of the canvas
                ctx.scale(-1, 1); // Flip horizontally by scaling x by -1
        
                // Draw the video frame to the offscreen canvas (mirrored)
                ctx.drawImage(video, 0, 0, videoWidth, videoHeight);
        
                // Restore the context to its original state so any overlays aren't mirrored
                ctx.restore();
        
                let imageData = ctx.getImageData(0, 0, videoWidth, videoHeight);
                src.data.set(imageData.data);
        
                // Convert to HSV color space
                cv.cvtColor(src, hsv, cv.COLOR_RGBA2RGB);
                cv.cvtColor(hsv, hsv, cv.COLOR_RGB2HSV);
        
                // Create masks for both colors
                let lower1 = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), lowerHSV1);
                let upper1 = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), upperHSV1);
                let mask1 = new cv.Mat();
                cv.inRange(hsv, lower1, upper1, mask1);
        
                let lower2 = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), lowerHSV2);
                let upper2 = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), upperHSV2);
                let mask2 = new cv.Mat();
                cv.inRange(hsv, lower2, upper2, mask2);
        
                // Find contours for both masks
                let contours1 = new cv.MatVector();
                let hierarchy1 = new cv.Mat();
                cv.findContours(mask1, contours1, hierarchy1, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
        
                let contours2 = new cv.MatVector();
                let hierarchy2 = new cv.Mat();
                cv.findContours(mask2, contours2, hierarchy2, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
        
                // Prepare contours info
                let contoursInfo1 = [];
                let contoursInfo2 = [];
        
                for (let i = 0; i < contours1.size(); i++) {
                    let cnt = contours1.get(i);
                    let area = cv.contourArea(cnt);
                    if (area > 100) { // Adjust minimum area as needed
                        let rect = cv.boundingRect(cnt);
                        contoursInfo1.push({ contour: cnt, rect: rect });
                    } else {
                        cnt.delete();
                    }
                }
        
                for (let i = 0; i < contours2.size(); i++) {
                    let cnt = contours2.get(i);
                    let area = cv.contourArea(cnt);
                    if (area > 100) {
                        let rect = cv.boundingRect(cnt);
                        contoursInfo2.push({ contour: cnt, rect: rect });
                    } else {
                        cnt.delete();
                    }
                }
        
                // Find candidate pairs
                let candidatePairs = [];
        
                for (let info1 of contoursInfo1) {
                    let center1 = getCenter(info1.rect);
                    let width1 = info1.rect.width;
        
                    for (let info2 of contoursInfo2) {
                        let center2 = getCenter(info2.rect);
                        let width2 = info2.rect.width;
        
                        let dx = center1.x - center2.x;
                        let dy = center1.y - center2.y;
                        let distanceBetweenCenters = Math.sqrt(dx * dx + dy * dy);
        
                        let widthSum = width1 + width2;
        
                        if (distanceBetweenCenters < widthSum) {
                            // The contours are close enough
                            let totalWidth = width1 + width2;
                            candidatePairs.push({
                                info1: info1,
                                info2: info2,
                                totalWidth: totalWidth
                            });
                        }
                    }
                }
        
                let distance = null;
        
                if (candidatePairs.length > 0) {
                    // Select the pair with the largest sum of widths
                    candidatePairs.sort((a, b) => b.totalWidth - a.totalWidth);
                    let bestPair = candidatePairs[0];
        
                    let rect1 = bestPair.info1.rect;
                    let rect2 = bestPair.info2.rect;
        
                    // Compute the bounding box around both rects
                    let x = Math.min(rect1.x, rect2.x);
                    let y = Math.min(rect1.y, rect2.y);
                    let x2 = Math.max(rect1.x + rect1.width, rect2.x + rect2.width);
                    let y2 = Math.max(rect1.y + rect1.height, rect2.y + rect2.height);
        
                    let boundingRect = {
                        x: x,
                        y: y,
                        width: x2 - x,
                        height: y2 - y
                    };
        
                    // Draw the bounding box
                    cv.rectangle(src, new cv.Point(boundingRect.x, boundingRect.y), new cv.Point(boundingRect.x + boundingRect.width, boundingRect.y + boundingRect.height), [0, 255, 0, 255], 2);
        
                    // Estimate distance based on bounding box width
                    if (focalLength !== null) {
                        const observedWidth = boundingRect.width;
                        distance = (realWidth * focalLength) / observedWidth;
                        distance = parseFloat(distance.toFixed(2)); // in inches
                    } else {
                        // If not calibrated, display message
                        distance = null;
                    }
        
                    // Draw distance text
                    cv.putText(src, distance !== null ? distance + " inches" : "Not calibrated", new cv.Point(boundingRect.x, boundingRect.y - 10), cv.FONT_HERSHEY_SIMPLEX, 0.6, [0, 255, 0, 255]);
        
                    // Optionally, draw the individual bounding boxes
                    cv.rectangle(src, new cv.Point(rect1.x, rect1.y), new cv.Point(rect1.x + rect1.width, rect1.y + rect1.height), [255, 0, 0, 255], 2); // Color 1 contours in blue
                    cv.rectangle(src, new cv.Point(rect2.x, rect2.y), new cv.Point(rect2.x + rect2.width, rect2.y + rect2.height), [0, 0, 255, 255], 2); // Color 2 contours in red
                }
        
                // If graphing is active and distance is valid
                if (graphing && distance !== null) {
                    let currentTime = (Date.now() - startTime) / 1000; // in seconds
                    let dataPoint = {
                        x: parseFloat(currentTime.toFixed(2)),
                        y: distance
                    };
                    chart.data.datasets[0].data.push(dataPoint);
                    chart.update();
                }
        
                // Show the processed frame
                cv.imshow('canvasOutput', src);
        
                // Clean up
                for (let info of contoursInfo1) {
                    info.contour.delete();
                }
                for (let info of contoursInfo2) {
                    info.contour.delete();
                }
                contours1.delete();
                contours2.delete();
                hierarchy1.delete();
                hierarchy2.delete();
                lower1.delete();
                upper1.delete();
                mask1.delete();
                lower2.delete();
                upper2.delete();
                mask2.delete();
        
                // Schedule the next frame
                requestAnimationFrame(processFrame);
            } catch (err) {
                console.error("Error in processing frame:", err);
            }
        }

        // Start processing frames
        requestAnimationFrame(processFrame);
    }

    function calibrateCamera() {
        const video = document.getElementById('videoElement');
        const canvasFrame = document.createElement('canvas');
        const ctx = canvasFrame.getContext('2d', { willReadFrequently: true });

        // Get user inputs
        const distanceInput = document.getElementById('distanceInput');
        const widthInput = document.getElementById('widthInput');

        knownDistance = parseFloat(distanceInput.value);
        realWidth = parseFloat(widthInput.value);

        if (isNaN(knownDistance) || isNaN(realWidth)) {
            alert("Please enter valid numbers for distance and width.");
            return;
        }

        // Capture current frame and process
        const videoWidth = video.videoWidth;
        const videoHeight = video.videoHeight;

        canvasFrame.width = videoWidth;
        canvasFrame.height = videoHeight;

        const src = new cv.Mat(videoHeight, videoWidth, cv.CV_8UC4);
        const hsv = new cv.Mat();

        // Draw the video frame to the offscreen canvas
        ctx.drawImage(video, 0, 0, videoWidth, videoHeight);
        let imageData = ctx.getImageData(0, 0, videoWidth, videoHeight);
        src.data.set(imageData.data);

        // Convert to HSV color space
        cv.cvtColor(src, hsv, cv.COLOR_RGBA2RGB);
        cv.cvtColor(hsv, hsv, cv.COLOR_RGB2HSV);

        // Create masks for both colors
        let lower1 = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), lowerHSV1);
        let upper1 = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), upperHSV1);
        let mask1 = new cv.Mat();
        cv.inRange(hsv, lower1, upper1, mask1);

        let lower2 = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), lowerHSV2);
        let upper2 = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), upperHSV2);
        let mask2 = new cv.Mat();
        cv.inRange(hsv, lower2, upper2, mask2);

        // Find contours for both masks
        let contours1 = new cv.MatVector();
        let hierarchy1 = new cv.Mat();
        cv.findContours(mask1, contours1, hierarchy1, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

        let contours2 = new cv.MatVector();
        let hierarchy2 = new cv.Mat();
        cv.findContours(mask2, contours2, hierarchy2, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

        // Prepare contours info
        let contoursInfo1 = [];
        let contoursInfo2 = [];

        for (let i = 0; i < contours1.size(); i++) {
            let cnt = contours1.get(i);
            let area = cv.contourArea(cnt);
            if (area > 100) {
                let rect = cv.boundingRect(cnt);
                contoursInfo1.push({ contour: cnt, rect: rect });
            } else {
                cnt.delete();
            }
        }

        for (let i = 0; i < contours2.size(); i++) {
            let cnt = contours2.get(i);
            let area = cv.contourArea(cnt);
            if (area > 100) {
                let rect = cv.boundingRect(cnt);
                contoursInfo2.push({ contour: cnt, rect: rect });
            } else {
                cnt.delete();
            }
        }

        // Find candidate pairs
        let candidatePairs = [];

        for (let info1 of contoursInfo1) {
            let center1 = getCenter(info1.rect);
            let width1 = info1.rect.width;

            for (let info2 of contoursInfo2) {
                let center2 = getCenter(info2.rect);
                let width2 = info2.rect.width;

                let dx = center1.x - center2.x;
                let dy = center1.y - center2.y;
                let distanceBetweenCenters = Math.sqrt(dx * dx + dy * dy);

                let widthSum = width1 + width2;

                if (distanceBetweenCenters < widthSum) {
                    // The contours are close enough
                    let totalWidth = width1 + width2;
                    candidatePairs.push({
                        info1: info1,
                        info2: info2,
                        totalWidth: totalWidth
                    });
                }
            }
        }

        if (candidatePairs.length > 0) {
            // Select the pair with the largest sum of widths
            candidatePairs.sort((a, b) => b.totalWidth - a.totalWidth);
            let bestPair = candidatePairs[0];

            let rect1 = bestPair.info1.rect;
            let rect2 = bestPair.info2.rect;

            // Compute the bounding box around both rects
            let x = Math.min(rect1.x, rect2.x);
            let y = Math.min(rect1.y, rect2.y);
            let x2 = Math.max(rect1.x + rect1.width, rect2.x + rect2.width);
            let y2 = Math.max(rect1.y + rect1.height, rect2.y + rect2.height);

            let boundingRect = {
                x: x,
                y: y,
                width: x2 - x,
                height: y2 - y
            };

            const observedWidth = boundingRect.width;

            // Calculate focal length
            focalLength = (observedWidth * knownDistance) / realWidth;
            alert("Calibration successful!");

            // Clean up
            for (let info of contoursInfo1) {
                info.contour.delete();
            }
            for (let info of contoursInfo2) {
                info.contour.delete();
            }
        } else {
            alert("No object detected during calibration. Please make sure the object is visible and try again.");

            // Clean up
            for (let info of contoursInfo1) {
                info.contour.delete();
            }
            for (let info of contoursInfo2) {
                info.contour.delete();
            }
        }

        // Clean up
        src.delete();
        hsv.delete();
        contours1.delete();
        contours2.delete();
        hierarchy1.delete();
        hierarchy2.delete();
        lower1.delete();
        upper1.delete();
        mask1.delete();
        lower2.delete();
        upper2.delete();
        mask2.delete();
    }

    function initializeChart() {
        const ctx = document.getElementById('distanceChart').getContext('2d');
        chart = new Chart(ctx, {
            type: 'line',
            data: {
                datasets: [{
                    label: 'Distance (inches)',
                    data: [],
                    borderColor: 'blue',
                    fill: false,
                    pointRadius: 2,
                    pointHoverRadius: 5
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false, // Disable animations
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Time (seconds)'
                        },
                        type: 'linear',
                        position: 'bottom',
                        ticks: {
                            autoSkip: true,
                            maxTicksLimit: 10
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'Distance (inches)'
                        },
                        beginAtZero: true,
                        ticks: {
                            autoSkip: true,
                            maxTicksLimit: 10
                        }
                    }
                }
            }
        });
        // Add event listener for double-clicks on data points
        chart.canvas.addEventListener('dblclick', function(event) {
            const points = chart.getElementsAtEventForMode(event, 'nearest', { intersect: true }, false);
        
            if (points.length) {
                const pointIndex = points[0].index;
                // Remove the data point
                chart.data.datasets[0].data.splice(pointIndex, 1);
                chart.update();
            }
        });
    }

    function beginGraphing() {
        if (!graphing) {
            graphing = true;
            startTime = Date.now();
            chart.data.datasets[0].data = [];
            chart.update();
            document.getElementById('beginGraphingButton').textContent = 'Stop Graphing';
        } else {
            graphing = false;
            document.getElementById('beginGraphingButton').textContent = 'Begin Graphing';
        }
    }

    function clearGraph() {
        graphing = false;
        document.getElementById('beginGraphingButton').textContent = 'Begin Graphing';
        chart.data.datasets[0].data = [];
        chart.update();
    }
</script>

</body>
</html>
