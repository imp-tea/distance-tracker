<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Neon Green Square Distance Tracker</title>
    <style>
        /* Basic CSS to center and size video and canvas elements */
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            font-family: Arial, sans-serif;
        }
        video, canvas {
            width: 640px;
            height: 480px;
            border: 1px solid #333;
        }
    </style>
    <!-- Load OpenCV.js from CDN with defer attribute -->
    <script defer src="https://docs.opencv.org/3.4.0/opencv.js"></script>
</head>
<body>

<h2>Neon Green Square Distance Tracker</h2>
<!-- Video element to capture from webcam -->
<video id="videoElement" autoplay playsinline></video>

<!-- Canvas element to show the processed video with distance overlay -->
<canvas id="canvasOutput"></canvas>

<!-- Main JavaScript for the tracker functionality -->
<script>
// Poll every 100ms to check if OpenCV is loaded, instead of relying solely on cv['onRuntimeInitialized']
function checkOpenCVReady() {
    if (cv && cv.Mat) {
        console.log("OpenCV.js is ready (alternative check).");
        openCVReady = true;
        if (videoReady) {
            startProcessing();
        }
    } else {
        setTimeout(checkOpenCVReady, 100); // Retry every 100ms
    }
}
  
    
document.addEventListener('DOMContentLoaded', function() {
    console.log("DOM Content loaded...");
    const video = document.getElementById('videoElement');

    // Access webcam
    navigator.mediaDevices.getUserMedia({ video: true })
    .then(stream => {
        video.srcObject = stream;
        console.log("Video feed successfully accessed");
    })
    .catch(error => {
        console.error("Error accessing the webcam: ", error);
    });

    // Wait for video to be ready
    video.addEventListener('canplay', () => {
        console.log("Video is ready to play");
        videoReady = true;
        if (openCVReady) {
            startProcessing();
        }
    });

    // Check OpenCV initialization using the alternative approach
    checkOpenCVReady();
});

function startProcessing() {
    const video = document.getElementById('videoElement');
    const canvasOutput = document.getElementById('canvasOutput');
    const canvasFrame = document.createElement('canvas');
    const ctx = canvasFrame.getContext('2d');

    // Set canvas sizes to match video dimensions
    const videoWidth = video.videoWidth;
    const videoHeight = video.videoHeight;
    console.log("Video dimensions:", videoWidth, videoHeight);

    canvasOutput.width = videoWidth;
    canvasOutput.height = videoHeight;
    canvasFrame.width = videoWidth;
    canvasFrame.height = videoHeight;

    const src = new cv.Mat(videoHeight, videoWidth, cv.CV_8UC4);
    const hsv = new cv.Mat();
    const mask = new cv.Mat();

    function processFrame() {
        try {
            // Draw the video frame to the offscreen canvas
            ctx.drawImage(video, 0, 0, videoWidth, videoHeight);
            let imageData = ctx.getImageData(0, 0, videoWidth, videoHeight);
            src.data.set(imageData.data);

            // Convert to HSV color space
            cv.cvtColor(src, hsv, cv.COLOR_RGBA2RGB);
            cv.cvtColor(hsv, hsv, cv.COLOR_RGB2HSV);

            // Define HSV range for neon green
            let lower = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [40, 150, 150, 0]);
            let upper = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [80, 255, 255, 255]);
            cv.inRange(hsv, lower, upper, mask);

            // Find contours
            let contours = new cv.MatVector();
            let hierarchy = new cv.Mat();
            cv.findContours(mask, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

            for (let i = 0; i < contours.size(); i++) {
                let cnt = contours.get(i);
                let rect = cv.boundingRect(cnt);

                // Estimate distance based on bounding box width
                const knownDistance = 24; // Calibrated distance in inches
                const realWidth = 6; // Real width of object in inches
                const observedWidth = rect.width;
                const distance = (knownDistance * realWidth) / observedWidth;

                // Draw bounding box and distance text on the frame
                cv.rectangle(src, new cv.Point(rect.x, rect.y), new cv.Point(rect.x + rect.width, rect.y + rect.height), [0, 255, 0, 255], 2);
                cv.putText(src, `${distance.toFixed(2)} inches`, new cv.Point(rect.x, rect.y - 10), cv.FONT_HERSHEY_SIMPLEX, 0.6, [0, 255, 0, 255]);
            }

            // Show the processed frame
            cv.imshow('canvasOutput', src);

            // Clean up
            contours.delete();
            hierarchy.delete();
            lower.delete();
            upper.delete();

            // Schedule the next frame
            requestAnimationFrame(processFrame);
        } catch (err) {
            console.error("Error in processing frame:", err);
        }
    }

    // Start processing frames
    requestAnimationFrame(processFrame);
}
</script>

</body>
</html>
